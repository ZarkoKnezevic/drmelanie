---
description: TypeScript patterns and type safety rules for Next.js 14 with strict type checking
globs: ["**/*.{ts,tsx}"]
---

# Next.js 14 TypeScript Development Rules

## TYPE SAFETY FUNDAMENTALS

### ✅ ALWAYS: Strict Type Definitions
```tsx
// ✅ Comprehensive interface definitions
interface User {
  readonly id: string
  name: string
  email: string
  role: 'admin' | 'user' | 'moderator'
  profile: UserProfile | null
  preferences: UserPreferences
  createdAt: Date
  updatedAt: Date
}

interface UserProfile {
  avatar?: string
  bio?: string
  website?: string
  location?: string
}

interface UserPreferences {
  theme: 'light' | 'dark' | 'system'
  notifications: {
    email: boolean
    push: boolean
    marketing: boolean
  }
  privacy: {
    profileVisibility: 'public' | 'private' | 'friends'
    showEmail: boolean
  }
}

// ✅ API Response typing
interface ApiResponse<T> {
  data: T
  message: string
  success: boolean
  timestamp: string
}

interface PaginatedResponse<T> extends ApiResponse<T[]> {
  pagination: {
    page: number
    limit: number
    total: number
    totalPages: number
  }
}
```

### ❌ NEVER: Any or loose typing
```tsx
// ❌ DON'T: Use any type
function handleUser(user: any) {
  return user.name // No type safety
}

// ❌ DON'T: Untyped objects
const userConfig = {
  settings: {}, // Unknown structure
  data: [] // Unknown array type
}

// ✅ DO: Proper typing
function handleUser(user: User): string {
  return user.name // Type safe
}

const userConfig: UserConfig = {
  settings: defaultSettings,
  data: [] as UserData[]
}
```

## NEXT.JS SPECIFIC TYPES

### ✅ Page and Layout Types
```tsx
// Page component types
interface PageProps {
  params: { id: string }
  searchParams: { [key: string]: string | string[] | undefined }
}

export default async function UserPage({ params, searchParams }: PageProps) {
  const user = await getUser(params.id)
  return <UserProfile user={user} />
}

// Layout component types  
interface LayoutProps {
  children: React.ReactNode
  params: { locale: string }
}

export default function Layout({ children, params }: LayoutProps) {
  return (
    <div className="layout">
      <Navigation locale={params.locale} />
      {children}
    </div>
  )
}

// Metadata generation types
interface GenerateMetadataProps {
  params: { id: string }
  searchParams: { [key: string]: string | string[] | undefined }
}

export async function generateMetadata({
  params,
}: GenerateMetadataProps): Promise<Metadata> {
  const user = await getUser(params.id)
  
  return {
    title: `${user.name} - Profile`,
    description: user.bio || `Profile page for ${user.name}`,
  }
}
```

### ✅ API Route Types
```tsx
// API route handlers
import { NextRequest, NextResponse } from 'next/server'

interface RouteContext {
  params: { id: string }
}

export async function GET(
  request: NextRequest,
  context: RouteContext
): Promise<NextResponse<ApiResponse<User>>> {
  try {
    const user = await getUserById(context.params.id)
    
    return NextResponse.json({
      data: user,
      message: 'User retrieved successfully',
      success: true,
      timestamp: new Date().toISOString(),
    })
  } catch (error) {
    return NextResponse.json(
      {
        data: null as any,
        message: 'Failed to retrieve user',
        success: false,
        timestamp: new Date().toISOString(),
      },
      { status: 500 }
    )
  }
}

export async function POST(
  request: NextRequest
): Promise<NextResponse<ApiResponse<User>>> {
  try {
    const body: CreateUserRequest = await request.json()
    const user = await createUser(body)
    
    return NextResponse.json({
      data: user,
      message: 'User created successfully',
      success: true,
      timestamp: new Date().toISOString(),
    })
  } catch (error) {
    return NextResponse.json(
      {
        data: null as any,
        message: 'Failed to create user',
        success: false,
        timestamp: new Date().toISOString(),
      },
      { status: 400 }
    )
  }
}
```

## FORM AND VALIDATION TYPES

### ✅ Zod Schema Integration
```tsx
import { z } from 'zod'

// ✅ Zod schema with proper validation
export const userSchema = z.object({
  name: z.string()
    .min(2, 'Name must be at least 2 characters')
    .max(50, 'Name must be less than 50 characters'),
  email: z.string()
    .email('Invalid email address')
    .max(100, 'Email must be less than 100 characters'),
  role: z.enum(['admin', 'user', 'moderator']),
  profile: z.object({
    bio: z.string().max(500).optional(),
    website: z.string().url().optional(),
    avatar: z.string().url().optional(),
  }).optional(),
  preferences: z.object({
    theme: z.enum(['light', 'dark', 'system']),
    notifications: z.object({
      email: z.boolean(),
      push: z.boolean(),
      marketing: z.boolean(),
    }),
  }),
})

// ✅ Infer types from schema
export type UserFormData = z.infer<typeof userSchema>
export type CreateUserRequest = UserFormData
export type UpdateUserRequest = Partial<UserFormData> & { id: string }

// ✅ Form component with proper typing
interface UserFormProps {
  initialData?: Partial<UserFormData>
  onSubmit: (data: UserFormData) => Promise<void>
  isLoading?: boolean
}

export function UserForm({ initialData, onSubmit, isLoading }: UserFormProps) {
  const form = useForm<UserFormData>({
    resolver: zodResolver(userSchema),
    defaultValues: {
      name: initialData?.name || '',
      email: initialData?.email || '',
      role: initialData?.role || 'user',
      preferences: {
        theme: 'system',
        notifications: {
          email: true,
          push: false,
          marketing: false,
        },
        ...initialData?.preferences,
      },
    },
  })
  
  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        {/* Form fields */}
      </form>
    </Form>
  )
}
```

## GENERIC TYPE PATTERNS

### ✅ Reusable Generic Types
```tsx
// ✅ Generic data fetching types
interface DataState<T> {
  data: T | null
  loading: boolean
  error: string | null
}

interface PaginatedData<T> {
  items: T[]
  pagination: {
    page: number
    limit: number
    total: number
    totalPages: number
  }
}

// ✅ Generic API functions
async function fetchData<T>(
  url: string,
  options?: RequestInit
): Promise<ApiResponse<T>> {
  const response = await fetch(url, options)
  
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`)
  }
  
  return response.json()
}

async function fetchPaginatedData<T>(
  url: string,
  params: PaginationParams
): Promise<PaginatedResponse<T>> {
  const searchParams = new URLSearchParams({
    page: params.page.toString(),
    limit: params.limit.toString(),
  })
  
  return fetchData<T[]>(`${url}?${searchParams}`)
}

// ✅ Generic hook types
interface UseDataOptions<T> {
  initialData?: T
  onSuccess?: (data: T) => void
  onError?: (error: Error) => void
}

function useData<T>(
  fetcher: () => Promise<T>,
  options: UseDataOptions<T> = {}
): DataState<T> {
  const [state, setState] = useState<DataState<T>>({
    data: options.initialData || null,
    loading: false,
    error: null,
  })
  
  // Hook implementation...
  
  return state
}
```

### ✅ Component Generic Types
```tsx
// ✅ Generic table component
interface Column<T> {
  key: keyof T
  label: string
  render?: (value: T[keyof T], item: T) => React.ReactNode
}

interface DataTableProps<T> {
  data: T[]
  columns: Column<T>[]
  keyExtractor: (item: T) => string
  onRowClick?: (item: T) => void
  loading?: boolean
  emptyMessage?: string
}

export function DataTable<T>({
  data,
  columns,
  keyExtractor,
  onRowClick,
  loading = false,
  emptyMessage = 'No data available',
}: DataTableProps<T>) {
  if (loading) {
    return <TableSkeleton />
  }
  
  if (data.length === 0) {
    return <EmptyState message={emptyMessage} />
  }
  
  return (
    <Table>
      <TableHeader>
        <TableRow>
          {columns.map((column) => (
            <TableHead key={String(column.key)}>
              {column.label}
            </TableHead>
          ))}
        </TableRow>
      </TableHeader>
      <TableBody>
        {data.map((item) => (
          <TableRow
            key={keyExtractor(item)}
            onClick={() => onRowClick?.(item)}
            className={onRowClick ? 'cursor-pointer hover:bg-muted' : ''}
          >
            {columns.map((column) => (
              <TableCell key={String(column.key)}>
                {column.render 
                  ? column.render(item[column.key], item)
                  : String(item[column.key])
                }
              </TableCell>
            ))}
          </TableRow>
        ))}
      </TableBody>
    </Table>
  )
}

// ✅ Usage with proper typing
const userColumns: Column<User>[] = [
  { key: 'name', label: 'Name' },
  { key: 'email', label: 'Email' },
  { 
    key: 'role', 
    label: 'Role',
    render: (value) => <Badge variant="outline">{value}</Badge>
  },
]

export function UserTable({ users }: { users: User[] }) {
  return (
    <DataTable
      data={users}
      columns={userColumns}
      keyExtractor={(user) => user.id}
      onRowClick={(user) => router.push(`/users/${user.id}`)}
    />
  )
}
```

## UTILITY TYPE PATTERNS

### ✅ Advanced TypeScript Utilities
```tsx
// ✅ Pick specific fields
type UserSummary = Pick<User, 'id' | 'name' | 'email'>

// ✅ Omit sensitive fields  
type PublicUser = Omit<User, 'email' | 'preferences'>

// ✅ Make fields optional
type PartialUserUpdate = Partial<Pick<User, 'name' | 'profile'>>

// ✅ Create required subset
type RequiredUserFields = Required<Pick<User, 'name' | 'email'>>

// ✅ Conditional types
type UserWithProfile<T extends boolean> = T extends true 
  ? User & { profile: Required<UserProfile> }
  : User

// ✅ Template literal types
type UserEvent = `user:${string}` | `profile:${string}`

// ✅ Record types for lookups
type UserRolePermissions = Record<User['role'], string[]>

const rolePermissions: UserRolePermissions = {
  admin: ['read', 'write', 'delete', 'manage'],
  moderator: ['read', 'write', 'moderate'],
  user: ['read'],
}

// ✅ Mapped types
type UserFormErrors = {
  [K in keyof UserFormData]?: string
}

// ✅ Index signature types
interface UserSettings {
  [key: string]: string | number | boolean
  theme: 'light' | 'dark'
  notifications: boolean
}
```

## ASYNC AND PROMISE TYPES

### ✅ Proper Promise Typing
```tsx
// ✅ Async function return types
async function getUser(id: string): Promise<User> {
  const response = await fetch(`/api/users/${id}`)
  
  if (!response.ok) {
    throw new Error('Failed to fetch user')
  }
  
  return response.json()
}

async function getUsers(
  filters?: UserFilters
): Promise<PaginatedResponse<User>> {
  const params = new URLSearchParams()
  
  if (filters?.role) params.set('role', filters.role)
  if (filters?.search) params.set('search', filters.search)
  
  const response = await fetch(`/api/users?${params}`)
  return response.json()
}

// ✅ Error handling with proper types
type AsyncResult<T> = {
  data?: T
  error?: Error
}

async function safeApiCall<T>(
  apiCall: () => Promise<T>
): Promise<AsyncResult<T>> {
  try {
    const data = await apiCall()
    return { data }
  } catch (error) {
    return { 
      error: error instanceof Error ? error : new Error('Unknown error')
    }
  }
}

// ✅ Usage
async function handleUserFetch(id: string) {
  const result = await safeApiCall(() => getUser(id))
  
  if (result.error) {
    console.error('Failed to fetch user:', result.error.message)
    return
  }
  
  // result.data is properly typed as User
  console.log('User loaded:', result.data.name)
}
```

## CONTEXT AND PROVIDER TYPES

### ✅ Typed Context Providers
```tsx
// ✅ Comprehensive context typing
interface UserContextValue {
  user: User | null
  loading: boolean
  login: (email: string, password: string) => Promise<void>
  logout: () => Promise<void>
  updateProfile: (data: Partial<UserProfile>) => Promise<void>
  refreshUser: () => Promise<void>
}

const UserContext = createContext<UserContextValue | null>(null)

export function useUser(): UserContextValue {
  const context = useContext(UserContext)
  
  if (!context) {
    throw new Error('useUser must be used within a UserProvider')
  }
  
  return context
}

interface UserProviderProps {
  children: React.ReactNode
  initialUser?: User | null
}

export function UserProvider({ children, initialUser }: UserProviderProps) {
  const [user, setUser] = useState<User | null>(initialUser || null)
  const [loading, setLoading] = useState(false)
  
  const login = async (email: string, password: string): Promise<void> => {
    setLoading(true)
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password }),
      })
      
      if (!response.ok) {
        throw new Error('Login failed')
      }
      
      const userData = await response.json()
      setUser(userData)
    } finally {
      setLoading(false)
    }
  }
  
  const value: UserContextValue = {
    user,
    loading,
    login,
    logout,
    updateProfile,
    refreshUser,
  }
  
  return (
    <UserContext.Provider value={value}>
      {children}
    </UserContext.Provider>
  )
}
```

## TYPE QUALITY CHECKLIST

### NEVER SHIP CODE WITHOUT:
- [ ] **All props interfaces** defined with proper types
- [ ] **API response types** matching backend contracts
- [ ] **Form validation schemas** with proper Zod integration
- [ ] **Error handling types** for all async operations
- [ ] **Generic constraints** where appropriate
- [ ] **Strict null checks** enabled and handled
- [ ] **No any types** unless absolutely necessary
- [ ] **Proper export/import** statements

### ALWAYS ENSURE:
- [ ] **Type safety** at compile time prevents runtime errors
- [ ] **IntelliSense support** works perfectly in VS Code
- [ ] **Refactoring safety** - changes propagate correctly
- [ ] **Documentation through types** - types explain the code
- [ ] **Performance optimized** - types don't affect runtime
- [ ] **Maintainable typing** - complex types are well-organized
- [ ] **Test coverage** includes type checking

Remember: **TypeScript is your safety net - embrace strict typing for bulletproof code.**
